using Dierckx
using IterTools
using GeometryTypes: Point2
using LinearAlgebra, Statistics

merge_nearby_points(line, th=0.01) = IterTools.imap( mean,
                                group_pairwise( (x,y) -> norm(x-y)<th, line ) )

function line2spline(line, th=0.01)
    # Merge almost-repeated points (which are sometimes generated by the contour
    # computation), to avoid numerical issues in spline computation.
    line = collect(merge_nearby_points(line,th))
    d = norm.(Tuple.(diff(line)))
    d ./= sum(d)
    # length parameter
    s = [0.0; cumsum(d)]
    # # vector of CartesianIndex => array with [x,y] pairs in columns
    # A = mapreduce(i->[i[2],i[1]], hcat, line)
    A = reduce(hcat, line)

    # output spline is approximately length-parameterized
    spl = ParametricSpline(s,A)
end

points(spline, x) = Point2.(eachcol(spline(x)))

resample_line(line, s) = points( line2spline(line), s )

#resample_spline(spl, s) = ParametricSpline(s,spl(s))
# do not assume input is length-parameterized
resample_spline(spl, s) = line2spline(eachcol(spl(s)))

function find_end_indices(c::Closed2DCurve, σc = 2.0, σκ = 5.0)
    cf = imfilter(c, Kernel.gaussian((σc,)))
    κ = curvature(cf)

    κm = imfilter(κ, Kernel.gaussian((σκ,)))
    i = collect(keys(n_highest_peaks_circular(κm, 2)))

    length(i) < 2 && @warn "Less than two curvature peaks found"
    i
end
find_ends( c, σc = 2.0, σκ = 5.0 ) = c[find_end_indices(c,σc,σκ)]

function ends_alignment_mask(ends)
    out = Vector{Bool}(undef,length(ends))
    out[1] = false   # Just for consistency. Not necessary for correct output.
    prev = ends[1]
    for i = 2:length(ends)
        curr = ends[i]
        curr_reversed = curr[[2,1]]
        out[i] = out[i-1] ⊻ (mean(norm.(curr .- prev)) > mean(norm.(curr_reversed .- prev)))
        prev = curr
    end
    out
end

function align_ends!(lines)
    ends = [(l[1], l[end]) for l in lines]
    switch_ends = ends_alignment_mask(ends)
    for i in eachindex(ends)
        switch_ends[i] && (lines[i] = reverse(lines[i]))
    end
    lines
end

# function align_ends(ends)
#     out = similar(ends)
#     prev = out[1] = ends[1]
#     for i = 2:length(ends)
#         curr = ends[i]
#         curr_reversed = curr[[2, 1]]
#         if mean(norm.(curr .- prev)) > mean(norm.(curr_reversed .- prev))
#             curr = curr_reversed
#         end
#         prev = out[i] = curr
#     end
#     out
# end


function contour2splines(c::Closed2DCurve)
    i,j = find_end_indices(c)
    contour2splines(c,(i,j))
end

function contour2splines(c::Closed2DCurve, (i, j))
    s = i>j
    n = length(c)
    half1, half2 = c[i:j+s*n], c[i+!s*n:-1:j]
    spl1, spl2 = line2spline(half1), line2spline(half2)
end

function swapat!(pairs, mask)
    for p in pairs[mask]
        p[1:2] = [p[2],p[1]]
    end
    pairs
end

function swapat(pairs,mask)
    out = similar(pairs)
    for i in eachindex(pairs)
        out[i] = mask[i] ? pairs[i][[2,1]] : copy(pairs[i])
    end
    out
end

splines2midline(spl1, spl2) = x -> mean.(zip(spl1(x),spl2(x)))

function aligned_splines(frames, σ=1.0, th=0.34)
    kern = Kernel.gaussian(σ)
    cs = [Elegans.raw_worm_contours(imfilter(fr,kern), th)
                for fr in frames]
    cs1 = [c[1] for c in cs]
    #plot(length.(cs1))
    ends_i = find_end_indices.(cs1)
    ends = [c[i] for (c,i) in zip(cs1,ends_i)]
    m = ends_alignment_mask(ends)
    ends_i_aligned = swapat(ends_i,m)
    #ends1 = [c[i[1]] for (c,i) in zip(cs1,ends_i_aligned)]
    #ends2 = [c[i[2]] for (c,i) in zip(cs1,ends_i_aligned)]
    spl = contour2splines.(cs1, ends_i_aligned)
    spl, cs
end
